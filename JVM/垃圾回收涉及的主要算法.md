- [1、对象存活算法引用计数法](#1------------)
    + [1.1 算法简介](#11-----)
    + [1.2 优缺点](#12----)
    + [1.3 实战](#13---)
- [2、对象存活算法可达性分析](#2------------)
    + [2.1、算法](#21---)
    + [2.2、java中可作为GC Root的对象有](#22-java----gc-root----)
- [3、标记清除算法](#3-------)
- [4、复制算法](#4-----)
    + [4.1 具体步骤](#41-----)
- [5、标记整理算法](#5-------)
- [6、分代收集算法](#6-------)

## 1、对象存活算法引用计数法

> 这个算法基本不再使用了，因为有非常明显的缺点

#### 1.1 算法简介

给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就+1；当引用失效时，计数器值就-1；任何时刻计数器为0的对象就是不可能在被使用

#### 1.2 优缺点
- **判定效率很高**，引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
- **不会完全准确**，因为如果出现两个对象相互引用的问题就不行了。就会出现内存泄漏的问题

#### 1.3 实战

```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void testGC() {
        
        //step 1
        ReferenceCountingGC objA = new ReferenceCountingGC();
        //step 2
        ReferenceCountingGC objB = new ReferenceCountingGC();
        //相互引用
        //step 3
        objA.instance = objB;
        //step 4
        objB.instance = objA;

        //step 5
        objA = null;
        //step 6
        objB = null;

        //假设在这行发生CG，objA和objB是否能被回收？   不能！！！！
        System.gc();
    }

    public static void main(String[] args) {
        testGC();
    }
}
```
```
step1：objA的引用+1   =1
step2：objB的引用+1   =1

step3：objB的引用+1   =2
step4：objA的引用+1   =2

step5：objA的引用-1   =1
step6：objB的引用-1   =1

永远都不会为0,GC永远都不会回收这些对象，导致内存泄漏
```

## 2、对象存活算法可达性分析

#### 2.1、算法

通过一系列的GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。

**当对象不可达时，并不是立即清除而是进行标记，标记为需要清除**

#### 2.2、java中可作为GC Root的对象有
- 虚拟机栈中引用的对象（本变量表）
- 本地方法栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象

![对象存活算法可达性](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%AE%97%E6%B3%95%E5%8F%AF%E8%BE%BE%E6%80%A7.jpg)

## 3、标记清除算法

> 这个算法也基本不再使用了

最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：
- 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是可达性分析中的标记。

**问题**
- 一个是效率问题，标记和清除两个过程的**效率都不高**
- 另一个是空间问题，标记清除之后会**产生大量不连续的内存碎片**，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到能够的连续内存而不得不提前触发另一次垃圾收集动作。

![标记清除](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.jpg)

## 4、复制算法
现在的商业虚拟机都采用这种收集算法来回收新生代，研究表明，新生代中的对象 98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden和其中一块 Survivor。 Survivor from 和Survivor to，内存比例 8：1：1

#### 4.1 具体步骤

- 当Eden区满的时候,会触发第一次young gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发young
gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。
- 当后续Eden又发生young gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。
- 可见部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代
- 注意：万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间

![复制算法](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg)

## 5、标记整理算法
> 该算法类似于标记清除算法，主要是用于老年代的GC回收

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法

根据老年代的特点，有人提出了另外一种“标记-整理（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向前端移动，然后直接清理掉端边界以外的内存。

![标记整理](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.jpg)


## 6、分代收集算法
- 一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法
- 在新生代中，每次垃圾收集时都发现有一批对象死去，只有少量存活，那就选择复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记法整理”算法来进行回收
