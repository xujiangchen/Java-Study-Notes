- [1、Java对象创建底层顺序](#1-java--------)
- [2、Java对象创建具体步骤](#2-java--------)
    + [2.1 步骤](#21---)
      - [中Java堆分配内存空间的方式主要有以下两种](#-java-----------------)
    + [2.2 可能会出现的问题](#22---------)
    + [2.3 初始化为零值](#23-------)
    + [2.4 对象相关数据](#24-------)
- [3、Java 对象的内存布局](#3-java--------)
    + [3.1 对象头](#31----)
      - [3.1.1 Mark Word 部分](#311-mark-word---)
      - [3.1.2 类型指针 部分](#312--------)
    + [3.2 实例数据](#32-----)
    + [3.3 对其填充](#33-----)
- [4、对象的访问](#4------)
    + [4.1 方式1：直接指针访问](#41---1-------)
    + [4.2 方式2：句柄访问](#42---2-----)
    + [4.3 两种访问方式的对比](#43----------)

## 1、Java对象创建底层顺序

![Java对象创建底层顺序](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%BA%95%E5%B1%82%E9%A1%BA%E5%BA%8F.jpg)

## 2、Java对象创建具体步骤

#### 2.1 步骤

- 虚拟机遇到一条new指令时，会先检查这个对应的类能否在常量池中定位到一个类的符号引用
- 判断这个类是否已被加载、解析和初始化
- 为这个新生对象在Java堆中分配内存空间
- 将分配到的内存空间都初始化为零值
- 设置对象相关数据
- 执行对象<init>方法

**扩展知识**
##### 中Java堆分配内存空间的方式主要有以下两种

> 指针碰撞：分配内存空间包括开辟一块内存和移动指针两个步骤

> 空闲列表：分配内存空间包括开辟一块内存和修改空闲列表两个步骤

![Java堆分配内存空间](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/Java%E5%A0%86%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.jpg)

#### 2.2 可能会出现的问题

指针碰撞 和 空闲列表 的操作可以看出分为两个步骤，那么就会出现原子性问题。Java虚拟机是如何解决这个问题的呢？
> 例如：现在有多个线程都要进行分配对象，这时候就会出现指针的碰撞或者空闲列表的碰撞，这时候就出现了线程不安全的问题，Java虚拟机采用乐观锁的方式进行一个CAS<sup>[1]</sup>的判断,以失败重试的方式保证更新操作的原子性

#### 2.3 初始化为零值

什么叫初始化话零值？

就是Java虚拟机对各种对象赋上初值；对于基础类型，类似于 int 的 初始化值 是0 ，boolean 的初始化值是false，而对于非基础类型就是 null

#### 2.4 对象相关数据

包括：
- GC分代年龄
- 对象的hashCode
- 元数据信息

**备注**

[1] : CAS是compareandswap的简称，从字面上理解就是比较并更新，简单来说：从某一内存上取值V，和预期值A进行比较，如果内存值V和预期值A的结果相等，那么我们就把新值B更新到内存，如果不相等，那么就重复上述操作直到成功为止。

## 3、Java 对象的内存布局

![Java对象结构](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg)

#### 3.1 对象头
- 主要是用于存储对象的元数据信息
- 分为两个部分 **Mark Word 部分** 和 **类型指针**

##### 3.1.1 Mark Word 部分

 哈希值 -> 返回对象的内存地址经过处理后的结构

- GC分代年龄 -> Java 虚拟机对垃圾回收时会分为新生代和老年代，然后根据不同的策略进行回收
- 锁状态 -> 多线程访问和操作这个对象的时候，为了保证线程安全的概念
- 线程持有锁 -> 存线程占有锁的指针

##### 3.1.2 类型指针 部分

- 指向它的类元数据的指针，用于判断对象属于哪个类的实例。

>Header长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，Mark Word 一般被设计为**非固定的数据结构**，以便存储更多的数据信息和复用自己的存储空间。

#### 3.2 实例数据

存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object   pointers)，**相同宽度的字段总是被分配到一起，便于之后取数据**。父类定义的变量会出现在子类定义的变量的前面。

#### 3.3 对其填充
- 对其填充部分仅仅起到占位符的作用

通过Header的大小可以看出，32和64都是8的倍数，**java对象的存储也遵循这个规则以8的倍数**，Header的大小可以确定，但是实例数据的大小就难以确定，这时候就通过对其填充部分将期变为8的倍数

## 4、对象的访问
- 访问对象的类型数据和实例数据

#### 4.1 方式1：直接指针访问
即reference中存储的就是对象地址，相当于⼀级指针。
- 对象实例数据（堆）:对象中各个实例字段的数据
- 对象类型数据（方法区）：对象的类型、父类、实现的接口、方法等
> 局部变量表存在栈中

![对象访问定位直接访问](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE.jpg)

#### 4.2 方式2：句柄访问
即reference中存储的是对象句柄的地址，⽽句柄中包含了对象实例数据
与类型数据的具体地址信息，相当于⼆级指针

![对象句柄访问](https://github.com/xujiangchen/Java-Study-Notes/blob/main/JVM/asset/%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg)

#### 4.3 两种访问方式的对比

**访问效率**

- 直接指针访问方式的最大好处是速度更快，它节省了一次时间定位的开销，由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本，而这也**是HotSpot采用的实现方式**

**垃圾回收**

- 句柄访问方式最大好处就是reference存放的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

